# CPP八股

## 面向对象

* 成员函数定义在类定义内部，编译器会**更有可能**将其视为内联函数(inline).

  inline 函数是将函数代码插入到函数调用的地方，提高程序性能。

  更有可能是因为，内联函数还要考虑函数的代码多少、复杂性等。

* 类的私有成员只能内部函数访问，无论是父类还是子类都不能直接访问到对方的private成员，但是若有一个function是关于这个private成员的，可以调用这个接口来访问

* 使用初始化列表来初始化字段，**初始化列表的顺序要跟你在类声明的顺序要一致**，否则会出现无法预料的结果。

* **拷贝构造函数**是指使用之前创建的对象来初始化新创建的对象，**使用场景**：1. 使用同类型的对象来初始化新创建的对象2. 复制对象把它作为参数传递给函数 3. 复制对象从函数返回

* **析构函数在类中只有一个**，是在对象生命周期结束时自动调用。(在main中有类的实例在，并且实例在main结束后仍然存在，*这里指的是在内存中存在*，会调用其析构函数，因此**析构函数可以在main结束后调用**)

* this指针指向当前对象的实例，当一个对象的成员函数被调用时，会隐式的传进去该对象的地址

  ```cpp
   double Volume(&Box)
        {
           return length * breadth * height;
        }
  ```

* 当我们将一个成员声明为static时，那么无论创建多少个对象，静态成员只有一个(**共享**)。继承的子类也**共享**这一个变量。

  当函数成员被声明为static时，可以脱离对象而调用，且里面涉及到其他成员只能访问到同为static的，

  **static变量必须在类的外部进行定义和初始化**，在类中只是声明。实际上在**类外给分配内存**。如果不存在其他的初始化语句，在创建第一个对象时，**所有的静态数据都会被初始化为零**

* 在一个类中重载函数调用运算符`()`，我们就可以类似调用函数一样使用类的对象，仿函数出现是为了代替函数指针，若使用内联函数再使用函数指针，那么编译器会将其视为普通函数而不是inline. 仿函数还有一个特点就是将状态和行为绑定在一起。

  ```cpp
  struct Accumulator {
      int sum;
      Accumulator() : sum(0) {}
      void operator()(int value) {
          sum += value;
      }
  };
  int main() {
      Accumulator accumulator;
      accumulator(5);  // 累积和为 5
      accumulator(3);  // 累积和为 8
      accumulator(10); // 累积和为 18
      std::cout << "Accumulated sum: " << accumulator.sum << std::endl;
      return 0;
  }
  ```

* 子类继承父类时，基类的构造函数、析构函数、拷贝构造函数、重载运算符、友元函数不能被继承。(**c++11中可以继承了**，要使用`using Base::Base`using是关键字，Base是举例)

  子类在调用自己的构造函数创建对象时，会先调用父类的构造函数，再调用自己的构造函数，例如：

  ```cpp
  // 派生类
  class Rectangle: public Shape
  {
     public:
        Rectangle(int a,int b)
        {
          Shape(a,b);//这样不可以！！
        }
  };

  // 派生类
  class Rectangle: public Shape
  {
     public:
        Rectangle(int a,int b):Shape(a,b)//这样可以！
        {
        }
  };
  ```

  ​